using System;
using System.Collections.Generic;
using System.Linq;

namespace ITHuset.DDD.AntiMalware.Domain.SeedWork
{
	/// <summary>
	/// Base class for Value Objects
	/// </summary>
	/// <remarks>
	/// Source taken from: https://enterprisecraftsmanship.com/2017/08/28/value-object-a-better-implementation/
	/// With some modifications.
	/// </remarks>
	public abstract class ValueObject
	{
		protected abstract IEnumerable<object> GetEqualityComponents();

		private IEnumerable<object> ValidateAndGetEqualityComponents()
		{
			var equalityComponents = GetEqualityComponents();
			if (equalityComponents == null || !equalityComponents.Any())
			{
				throw new InvalidOperationException($"{nameof(GetEqualityComponents)} must return at least one component.");
			}

			return equalityComponents;
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}

			if (GetType() != obj.GetType())
			{
				return false;
			}

			var valueObject = (ValueObject)obj;

			bool isEqual = ValidateAndGetEqualityComponents().SequenceEqual(valueObject.GetEqualityComponents());

			return isEqual;
		}

		public override int GetHashCode()
		{
			return ValidateAndGetEqualityComponents()
				.Aggregate(17, (current, obj) =>
				{
					unchecked
					{
						return current * 23 + (obj?.GetHashCode() ?? 0);
					}
				});
		}

#pragma warning disable S3875 // "operator==" should not be overloaded on reference types
		public static bool operator ==(ValueObject a, ValueObject b)
		{
			if (a is null && b is null)
			{
				return true;
			}

			if (a is null || b is null)
			{
				return false;
			}

			return a.Equals(b);
		}
#pragma warning restore S3875 // "operator==" should not be overloaded on reference types

		public static bool operator !=(ValueObject a, ValueObject b)
		{
			return !(a == b);
		}
	}
}
